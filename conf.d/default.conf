# ----------------------------------------
# HTTP-level logging & helpers
# ----------------------------------------

# Flag kubelet health probes by User-Agent
map $http_user_agent $is_probe { default 0; ~kube-probe 1; }

# Flag error statuses
map $status $is_error { default 0; ~^[45] 1; }

# Only log failing probe requests
map "$is_probe:$is_error" $log_probe_fail { default 0; "1:1" 1; }

# Log all non-probe requests (browsers/APIs)
map $is_probe $not_probe { 0 1; 1 0; }

# JSON access log for normal traffic
log_format json escape=json
  '{'
    '"ts":"$time_iso8601",'
    '"remote":"$remote_addr",'
    '"method":"$request_method",'
    '"uri":"$request_uri",'
    '"status":$status,'
    '"bytes":$body_bytes_sent,'
    '"rt":$request_time,'
    '"ref":"$http_referer",'
    '"ua":"$http_user_agent",'
    '"req_id":"$request_id"'
  '}';

  log_format json_analytics escape=json '{'
  '"msec": "$msec", ' # request unixtime in seconds with a milliseconds resolution
  '"connection": "$connection", ' # connection serial number
  '"connection_requests": "$connection_requests", ' # number of requests made in connection
  '"pid": "$pid", ' # process pid
  '"request_id": "$request_id", ' # the unique request id
  '"request_length": "$request_length", ' # request length (including headers and body)
  '"remote_addr": "$remote_addr", ' # client IP
  '"remote_user": "$remote_user", ' # client HTTP username
  '"remote_port": "$remote_port", ' # client port
  '"time_local": "$time_local", '
  '"time_iso8601": "$time_iso8601", ' # local time in the ISO 8601 standard format
  '"request": "$request", ' # full path no arguments if the request
  '"request_uri": "$request_uri", ' # full path and arguments if the request
  '"args": "$args", ' # args
  '"status": "$status", ' # response status code
  '"body_bytes_sent": "$body_bytes_sent", ' # the number of body bytes exclude headers sent to a client
  '"bytes_sent": "$bytes_sent", ' # the number of bytes sent to a client
  '"http_referer": "$http_referer", ' # HTTP referer
  '"http_user_agent": "$http_user_agent", ' # user agent
  '"http_x_forwarded_for": "$http_x_forwarded_for", ' # http_x_forwarded_for
  '"http_host": "$http_host", ' # the request Host: header
  '"server_name": "$server_name", ' # the name of the vhost serving the request
  '"request_time": "$request_time", ' # request processing time in seconds with msec resolution
  '"upstream": "$upstream_addr", ' # upstream backend server for proxied requests
  '"upstream_connect_time": "$upstream_connect_time", ' # upstream handshake time incl. TLS
  '"upstream_header_time": "$upstream_header_time", ' # time spent receiving upstream headers
  '"upstream_response_time": "$upstream_response_time", ' # time spent receiving upstream body
  '"upstream_response_length": "$upstream_response_length", ' # upstream response length
  '"upstream_cache_status": "$upstream_cache_status", ' # cache HIT/MISS where applicable
  '"ssl_protocol": "$ssl_protocol", ' # TLS protocol
  '"ssl_cipher": "$ssl_cipher", ' # TLS cipher
  '"scheme": "$scheme", ' # http or https
  '"request_method": "$request_method", ' # request method
  '"server_protocol": "$server_protocol", ' # request protocol, like HTTP/1.1 or HTTP/2.0
  '"pipe": "$pipe", ' # "p" if request was pipelined, "." otherwise
  '"gzip_ratio": "$gzip_ratio"'
  '}';

# Compact format for probe logs
log_format probe '$remote_addr - $time_local "$request" $status rt=$request_time';

# Send error logs to stderr
error_log /dev/stderr warn;


# ----------------------------------------
# Main server
# ----------------------------------------
server {
  listen 8080;
  server_name _;

  root /usr/share/nginx/html;
  index index.html;

  absolute_redirect off;
  port_in_redirect off;
  server_name_in_redirect off;

  # Access logging:
  access_log /dev/stdout json_analytics  if=$not_probe;       # all non-probe requests
  access_log /dev/stdout probe if=$log_probe_fail;  # ONLY failing probes

  # Directory listing for all paths
  location / {
    autoindex on;
    try_files $uri $uri/ =404;
  }

  location = /basic_status {
      stub_status;
    # Optionally restrict access to IP addresses if needed
    # allow 127.0.0.1;
    # deny all;
  }

  # Health endpoints (match probes)
  location = /healthz {
    access_log off;
    add_header Content-Type application/json;
    return 200 '{"status":"HEALTHY"}';
  }

  location = /healthz/startup {
    access_log off;
    add_header Content-Type application/json;
    return 200 '{"status":"STARTUP_OK"}';
  }

  location = /healthz/ready {
    access_log off;
    add_header Content-Type application/json;
    return 200 '{"status":"READY_OK"}';
  }

  # Optional nice to haves
  sendfile on;
  keepalive_timeout 65s;
}
